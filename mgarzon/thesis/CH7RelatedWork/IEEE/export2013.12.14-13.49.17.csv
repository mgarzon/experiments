"http://ieeexplore.ieee.org/myprojects/showProjectListings.jsp?projectId=269494",2013/12/14 13:49:17
"Document Title","Authors","Author Affiliations","Publication Title","Publication Date","Publication Year","Volume","Issue","Start Page","End Page","Abstract","ISSN","ISBN","EISBN","DOI",PDF Link,"Author Keywords","IEEE Terms","INSPEC Controlled Terms","INSPEC Non-Controlled Terms","DOE Terms","PACS Terms","MeSH Terms",Article Citation Count,Patent Citation Count,"Reference Count","Copyright Year","Online Date",Date Added To Xplore,"Meeting Date","Publisher","Sponsors",Document Identifier,Document Notes,Document Tags,Date Added,Update Date
"Exploring differences in exchange formats-tool support and case studies","Jiang, J.; Systa, T.","Inst. of Software Syst., Tampere Univ. of Technol., Finland","Software Maintenance and Reengineering, 2003. Proceedings. Seventh European Conference on","26-28 March 2003","2003","","","389","398","XML-based markup languages are widely used, e.g., for information exchange and as file formats in various software development and exploration tools. Still, using a metalanguage, such as XML, does not guarantee tool interoperability. The particular XML-based languages used by different tools often vary. They can, none the less, be processed by the same methods and tools. In most UML-based software development tools, support for tool interoperability is provided by using OMG's XML Metadata Interchange (XMI) as a file format. However, in many cases XMI has turned out to be insufficient for storing all information from the UML models. Thus the tool vendors typically extend and/or modify the language so introduce their own XMI dialect. This, in turn, means that the tool interoperability is sacrificed. We discuss a method and a tool called DTD-compaper for exploring differences in exchange formats. DTD-compaper can, in general, be used to identify differences in grammars of XML-based languages. Further, we discuss three different case studies in which we used DTD-comparer. We first compare few commonly used XMI dialects. We further use the tool for comparing different versions of the Graph eXchange Language (GXL).","1534-5351","0-7695-1902-4","","10.1109/CSMR.2003.1192448","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1192448","","Computer aided software engineering;Markup languages;Programming;Reverse engineering;Software libraries;Software maintenance;Software systems;Standards development;Unified modeling language;XML","data models;grammars;hypermedia markup languages;open systems;software tools;specification languages","DTD-compaper;GXL;Graph eXchange Language;UML;XMI;XML;XML Metadata Interchange;data model;file format;grammars;metalanguage;software development tools;software tools;tool interoperability","","","","1","","12","","","20030408","","IEEE","","IEEE Conference Publications","","","Dec. 14, 2013 1:48 PM EST","Dec. 14, 2013 1:48 PM EST"
"Extending a Model Transformation Language Using Higher Order Transformations","Muliawan, O.","Univ. Antwerpen, Antwerpen","Reverse Engineering, 2008. WCRE '08. 15th Working Conference on","15-18 Oct. 2008","2008","","","315","318","Model driven engineering is a paradigm for software development on different platforms. Models are (semi) automatically refined in a series of steps, each step adding more information to eventually produce software code. However, the specification of model transformations which define these refinements is still performed in a manual fashion. A specification may be very complex, difficult to understand or time-consuming to produce. There is need for a higher level language for improving expressivity of the basic transformation mechanism. Consequently, we need higher order transformations for converting the extra features adding expressivity into the basic formalism, thus providing a mechanism for implementing extensions to the core language. This approach is tested on a few cases including evolution and refinement to other paradigms (e.g. transformation from a UML activity diagram into communicating sequential processes).","1095-1350","978-0-7695-3429-9","","10.1109/WCRE.2008.19","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4656425","evolution;graph transformations;model driven engineering;refactoring","Model driven engineering;Productivity;Programming;Refining;Reverse engineering;Sequential analysis;Terminology;Unified modeling language","Unified Modeling Language;high level languages;software engineering","UML;communicating sequential processes;higher order transformations;model driven engineering;model transformation language;software code;transformation mechanism","","","","0","","13","","","20081024","","IEEE","","IEEE Conference Publications","","","Dec. 14, 2013 1:48 PM EST","Dec. 14, 2013 1:48 PM EST"
"Determining granularity of independent tasks for reengineering a legacy system into an OO system","Millham, R.; Ward, M.; Yang, H.","De Montfort Univ., Leicester, UK","Computer Software and Applications Conference, 2003. COMPSAC 2003. Proceedings. 27th Annual International","3-6 Nov. 2003","2003","","","342","347","Reengineering a COBOL legacy system is a difficult multi-step process, particularly when the COBOL legacy system is a sequential procedural-driven system which is being reengineered into an object oriented, event-driven system. In this scenario, it is necessary to analyse the legacy system in order to identify which tasks can be executed independently and which tasks must be executed sequentially. The focus of reengineering is too often based on theory rather than based on experience gained from real-world examples. This paper hopes to address this imbalance by providing a practical application of reengineering to an actual legacy telecommunications system.","0730-3157","0-7695-2020-0","","10.1109/CMPSAC.2003.1245363","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1245363","","Bars;Business communication;Communication switching;Companies;Control systems;Cost function;Object oriented modeling;Reverse engineering;System testing;Unified modeling language","distributed object management;object-oriented programming;reverse engineering;software maintenance;specification languages;systems re-engineering","COBOL;UML;Unified Modelling Language;WSL;event-driven system;independent task granularity determination;legacy system;legacy telecommunications system;object oriented system;object-oriented system;reverse enginering;sequential procedural-driven system;software reengineering;wide spectrum language","","","","0","","22","","","20031117","","IEEE","","IEEE Conference Publications","","","Dec. 14, 2013 1:48 PM EST","Dec. 14, 2013 1:48 PM EST"
"Discovering Program's Behavioral Patterns by Inferring Graph-Grammars from Execution Traces","Chunying Zhao; Ates, K.; Jun Kong; Kang Zhang","Univ. of Texas at Dallas, Dallas, TX","Tools with Artificial Intelligence, 2008. ICTAI '08. 20th IEEE International Conference on","3-5 Nov. 2008","2008","2","","395","402","Frequent patterns in program executions represent recurring sequences of events. These patterns can be used to reveal the hidden structures of a program, and ease the comprehension of legacy systems. Existing grammar-induction approaches generally use sequential algorithms to infer formal models from program executions, in which program executions are represented as strings. Software developers, however, often use graphs to illustrate the process of program executions, such as UML diagrams, flowcharts and call graphs. Taking advantage of graphs' expressiveness and intuitiveness for human cognition, we present a graph-grammar induction approach to discovering program's behavioral patterns by analyzing execution traces represented in graphs. Moreover, to improve the efficiency, execution traces are abstracted to filter redundant or unrelated traces. A grammar induction environment called VEGGIE is adopted to facilitate the induction. Evaluation is conducted on an open source project JHotDraw. Experimental results show the applicability of the proposed approach.","1082-3409","978-0-7695-3440-4","","10.1109/ICTAI.2008.68","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4669801","Graph-grammar Induction;Program Execution","Application software;Cognition;Flowcharts;Humans;Lattices;Pattern analysis;Reverse engineering;Sequences;Software engineering;Unified modeling language","data mining;graph grammars;learning by example;program diagnostics;program visualisation;software maintenance","execution trace;formal model;graph-grammar induction approach;legacy system comprehension;program behavioral pattern discovery;sequential algorithm;software developer;visual environment","","","","1","","14","","","20081111","","IEEE","","IEEE Conference Publications","","","Dec. 14, 2013 1:48 PM EST","Dec. 14, 2013 1:48 PM EST"
"Experiences with an industrial long-term reengineering project","Kollmann, R.","BOSS AG, Bremen, Germany","Reverse Engineering, 2004. Proceedings. 11th Working Conference on","8-12 Nov. 2004","2004","","","8","16","We discuss the experiences gained in a large-scale industrial reengineering project. The subject system is a medical data management software that has been continuously developed and maintained for about twenty years. About four years ago, it has been decided to subsequently reimplement the entire system in Java, while continuing maintenance of the legacy system. The focus of This work is less on technical details concerning reverse engineering tools, but rather on the overall approach for reengineering a large and complex legacy system. Central issues are the identification and definition of a suitable software development process, training for the developers, as well as the ongoing reverse engineering of the existing system. The latter has been carried out in parallel to continuous maintenance of both the legacy system and the reimplementation.","1095-1350","0-7695-2243-2","","10.1109/WCRE.2004.19","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1374301","","Application software;Computer industry;Databases;Industrial training;Java;Large-scale systems;Programming;Reverse engineering;Software development management;Software maintenance","Java;medical information systems;reverse engineering;software maintenance;systems re-engineering","Java;UML;XP;data reengineering;enterprise applications;industrial long-term reengineering project;large-scale industrial reengineering project;legacy system;medical data management software;parallel processing;reverse engineering tools;software development;system maintenance","","","","0","","22","","","20050117","","IEEE","","IEEE Conference Publications","","","Dec. 14, 2013 1:48 PM EST","Dec. 14, 2013 1:48 PM EST"
"“Reverse engineering”: Extracting information from C++ code","Jain, A.; Soner, S.; Holkar, A.","Dept. of Inf. Tech., Mahakal Inst. of Tech., Ujjain, India","Software Technology and Engineering (ICSTE), 2010 2nd International Conference on","3-5 Oct. 2010","2010","1","","V1-154","V1-158","This paper presents an experiment to reverse engineer a legacy source code. Here, it is used as a part of a project to develop and upgrade the existing system written in C++ language. To accomplish this task some information's must be need to be extracted from that legacy C++ code. The extracted information now used to implement a new version of the design documentation. This experiment revealed issues about recovering design information, such as, knowing variables, functions and classes. The reverse engineering process used to recover the Data flow diagrams, Control flow diagrams and class diagrams and the experience gained during the study are reported.","","978-1-4244-8667-0","978-1-4244-8666-3","10.1109/ICSTE.2010.5608892","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5608892","Class Diagrams;Control Flow Diagrams;Data Flow Diagrams;Extraction;Legacy code","Arrays;Business;Data mining;Data models;Maintenance engineering;Reverse engineering;Software","C++ language;data flow analysis;reverse engineering;software maintenance;system documentation","C++ language;class diagram;control flow diagram;data flow diagram;design documentation;design information recovery;legacy C++ code;legacy source code;reverse engineering","","","","0","","6","","","20101025","","IEEE","","IEEE Conference Publications","","","Dec. 14, 2013 1:48 PM EST","Dec. 14, 2013 1:48 PM EST"
"Identifying State Transitions and their Functions in Source Code","Walkinshaw, N.; Bogdanov, K.; Holcombe, M.","Dept. of Comput. Sci., Univ. of Sheffield","Testing: Academic and Industrial Conference - Practice And Research Techniques, 2006. TAIC PART 2006. Proceedings","29-31 Aug. 2006","2006","","","49","58","Finite state machine specifications form the basis for a number of rigorous state-based testing techniques and can help to understand program behaviour. Unfortunately they are rarely maintained during software development, which means that these benefits can rarely be fully exploited. This paper describes a technique that, given a set of states that are of interest to a developer, uses symbolic execution to reverse-engineer state transitions from source code. A particularly novel aspect of our approach is that, besides determining whether or not a state transition can take place, it also precisely identifies the path(s) through the source code that govern a transition. The technique has been implemented as a prototype, enabling a preliminary evaluation of our technique with respect to real software systems","","0-7695-2672-1","","10.1109/TAIC-PART.2006.12","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1691669","","Automata;Binary search trees;Computer science;Electronic mail;Power system modeling;Programming;Reverse engineering;Software maintenance;Software prototyping;System testing","finite state machines;formal specification;program testing;program verification;reverse engineering;software maintenance","finite state machine specification;program behaviour understanding;reverse-engineering;software maintenance;source code analysis;state transition identification;state-based testing technique;symbolic execution","","","","4","","19","","","20061016","","IEEE","","IEEE Conference Publications","","","Dec. 14, 2013 1:48 PM EST","Dec. 14, 2013 1:48 PM EST"
"Mining design patterns from C++ source code","Balanyi, Z.; Ferenc, R.","Res. Group on Artificial Intelligence, Szeged Univ., Hungary","Software Maintenance, 2003. ICSM 2003. Proceedings. International Conference on","22-26 Sept. 2003","2003","","","305","314","Design patterns are micro architectures that have proved to be reliable, easy-to implement and robust. There is a need in science and industry for recognizing these patterns. We present a new method for discovering design patterns in the source code. This method provides a precise specification of how the patterns work by describing basic structural information like inheritance, composition, aggregation and association, and as an indispensable part, by defining call delegation, object creation and operation overriding. We introduce a new XML-based language, the Design Pattern Markup Language (DPML), which provides an easy way for the users to modify pattern descriptions to suit their needs, or even to define their own patterns or just classes in certain relations they wish to find. We tested our method on four open-source systems, and found it effective in discovering design pattern instances.","1063-6773","0-7695-1905-9","","10.1109/ICSM.2003.1235436","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1235436","","Artificial intelligence;Design methodology;Markup languages;Open source software;Pattern recognition;Robustness;Software measurement;Software systems;System testing;Unified modeling language","C++ language;XML;reverse engineering;software architecture;specification languages","ASG;C++ language;Columbus Schema;DPML;Design Pattern Markup Language;UML;Unified Modeling Language;XML-based language;abstract semantic graph;call delegation;design pattern mining;formal specification;micro architectures;object creation;open-source systems;operation overriding;source code;structural information","","","","25","","20","","","20031007","","IEEE","","IEEE Conference Publications","","","Dec. 14, 2013 1:48 PM EST","Dec. 14, 2013 1:48 PM EST"
"An Analysis of Machine Learning Algorithms for Condensing Reverse Engineered Class Diagrams","Osman, Mohd Hafeez; Chaudron, Michel R.V.; Putten, Peter van der","","Software Maintenance (ICSM), 2013 29th IEEE International Conference on","22-28 Sept. 2013","2013","","","140","149","There is a range of techniques available to reverse engineer software designs from source code. However, these approaches generate highly detailed representations. The condensing of reverse engineered representations into more high-level design information would enhance the understandability of reverse engineered diagrams. This paper describes an automated approach for condensing reverse engineered diagrams into diagrams that look as if they are constructed as forward designed UML models. To this end, we propose a machine learning approach. The training set of this approach consists of a set of forward designed UML class diagrams and reverse engineered class diagrams (for the same system). Based on this training set, the method 'learns' to select the key classes for inclusion in the class diagrams. In this paper, we study a set of nine classification algorithms from the machine learning community and evaluate which algorithms perform best for predicting the key classes in a class diagram.","1063-6773","","","10.1109/ICSM.2013.25","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6676885","Machine Learning;Program Comprehension;Reverse Engineering;Software Engineering;UML","","","","","","","","","","","","20131202","","IEEE","","IEEE Conference Publications","","","Dec. 14, 2013 1:37 PM EST","Dec. 14, 2013 1:37 PM EST"
"Exploring How to Develop Transformations and Tools for Automated Umplification","Garzon, M.; Lethbridge, T.C.","Sch. of Electr. Eng. & Comput. Sci., Univ. of Ottawa, Ottawa, ON, Canada","Reverse Engineering (WCRE), 2012 19th Working Conference on","15-18 Oct. 2012","2012","","","491","494","In this research we are exploring how to perform incremental reverse engineering from Java to Umple, a process we call Umplification. Umple is a textual representation that blends modeling in UML with programming language code. It is designed to allow anything from pure textual modeling to almost-pure traditional programming with some modeling concepts added. Umplification involves increasing the proportion of modeling concepts in the code. Novel features of this work are: a) the transformations required are intended to be applied incrementally by a programmer who has a body of legacy code and wants to gradually transform it into Umple, preserving much of the layout, comments and other aspects of the original code if possible, b) the transformations required are at the same time code-to-model, model-to-model and code-to-code. The main contributions will be developing the transformations, developing a usable tool, and demonstrating its effectiveness by means of case studies.","1095-1350","978-1-4673-4536-1","","10.1109/WCRE.2012.58","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6385144","Incremental Reverse Engineering;Textual Modeling;Umple","Java;Prototypes;Reverse engineering;Semantics;Transforms;Unified modeling language","Java;programming languages;reverse engineering","Java;Umple;Umplification;automated umplification;legacy code;programming language code;reverse engineering;textual representation","","","","","","20","","","20121220","","IEEE","","IEEE Conference Publications","","","Dec. 14, 2013 1:37 PM EST","Dec. 14, 2013 1:37 PM EST"
"Understanding Web applications through dynamic analysis","Antoniol, G.; Di Penta, M.; Zazzara, M.","Dept. of Eng., Sannio Univ., Benevento, Italy","Program Comprehension, 2004. Proceedings. 12th IEEE International Workshop on","24-26 June 2004","2004","","","120","129","The relevance and pervasiveness of Web applications as a vital part of modern enterprise systems has significantly increased in recent years. However, the lack of adequate documentation promotes the need for reverse engineering tools aiming at supporting Web application maintenance and evolution tasks. A nontrivial Web application is a complex artifact integrating technologies such as scripting languages, middleware, Web services, data warehouses and databases. The task to recover abstractions requires the adoption of dynamic analyses to complement the information gathered with static analyses. This paper presents an approach and a tool, named WANDA, that instruments Web applications and combines static and dynamic information to recover the as-is architecture and, in general, the UML documentation of the application itself. To this aim we propose an extension of the Conallen UML diagrams to account for detailed dynamic information. The tool has been implemented and tested on several Web applications. Its architecture has been conceived to allow easy customization and extension. The paper presents our tool in the context of a program understanding task; however, it can be usefully applied to many other tasks such as profiling, security and dependability verification and application restructuring.","1092-8138","0-7695-2149-5","","10.1109/WPC.2004.1311054","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1311054","","Data warehouses;Databases;Documentation;Information analysis;Instruments;Middleware;Reverse engineering;Service oriented architecture;Unified modeling language;Web services","Internet;Unified Modeling Language;data warehouses;database management systems;diagrams;formal verification;middleware;reverse engineering;system documentation;systems analysis","Conallen UML diagrams;UML documentation;WANDA;Web application evolution;Web application maintenance;Web application understanding;Web services;data warehouses;databases;dynamic analysis;enterprise systems;middleware;program understanding;reverse engineering;scripting languages","","","","12","","25","","","20040712","","IEEE","","IEEE Conference Publications","","","Dec. 14, 2013 1:37 PM EST","Dec. 14, 2013 1:37 PM EST"
"Static and dynamic C++ code analysis for the recovery of the object diagram","Tonella, P.; Potrich, A.","Centro per la Ricerca Scientifica e Tecnologica, ITC-irst, Trento, Italy","Software Maintenance, 2002. Proceedings. International Conference on","2002","2002","","","54","63","When a software system enters the maintenance phase, the availability of accurate and consistent information about its organization can help alleviate the difficulties of program understanding. Reverse engineering methods aim at extracting such information directly from the code. While several tools support the recovery of the class diagram from object oriented code, so far no work has attacked the problem of statically characterizing the behavior of an object oriented system by means of diagrams which represent the class instances (objects) and their mutual relationships. In this paper a novel static analysis algorithm is proposed for extraction of the object diagram from the code, based on a program representation called the object flow graph. Partial object diagrams can be associated dynamically to the system by executing and tracing the program on a set of test cases. The complementary nature of these two views is discussed, and a novel approach to object oriented testing is derived from such a comparison. The usefulness of the proposed technique is illustrated on a real world, public domain C++ system.","1063-6773","0-7695-1819-2","","10.1109/ICSM.2002.1167747","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1167747","","Algorithm design and analysis;Collaboration;Data mining;Flow graphs;High performance computing;Information analysis;Maintenance;Reverse engineering;Software systems;System testing","diagrams;object-oriented programming;program diagnostics;reverse engineering;software maintenance","class instances;dynamic C++ code analysis;object diagram recovery;object flow graph;object oriented code;object oriented testing;partial object diagrams;program representation;program tracing;program understanding;public domain C++ system;reverse engineering methods;software maintenance;static C++ code analysis;static analysis algorithm","","","","6","","","","","20030129","","IEEE","","IEEE Conference Publications","","","Dec. 14, 2013 1:37 PM EST","Dec. 14, 2013 1:37 PM EST"
"Verification of recovered software architectures","Gannod, G.C.; Murthy, S.","Dept. of Comput. Sci. & Eng., Arizona State Univ., Tempe, AZ, USA","Program Comprehension, 2003. 11th IEEE International Workshop on","10-11 May 2003","2003","","","258","265","A common technique employed by software developers is the use of log files to generate traces of observed software behavior. As a resource for reverse engineering, a log file has the advantage of being an accurate account of software behavior. Model checking approaches work by using exploration to determine whether certain safety and liveness conditions are satisfied by a finite-state model. In this paper we describe an approach that combines the use of model checking and log file analysis to facilitate verification of recovered models.","1092-8138","0-7695-1883-4","","10.1109/WPC.2003.1199210","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1199210","","Computer architecture;Computer science;Engineering profession;Information resources;Instruments;NASA;Reverse engineering;Safety;Sampling methods;State-space methods","finite state machines;reverse engineering;software architecture","finite-state model;liveness conditions;log file analysis;log files;reverse engineering;safety;software architectures;software behavior;software developers","","","","0","","","","","20030521","","IEEE","","IEEE Conference Publications","","","Dec. 14, 2013 1:37 PM EST","Dec. 14, 2013 1:37 PM EST"
"Reengineering of Java Legacy System Based on Aspect-Oriented Programming","Liangyu Chen; Jianlin Wang; Ming Xu; Zhenbing Zeng","Shanghai Key Lab. of Trustworthy Comput., East China Normal Univ., Shanghai, China","Education Technology and Computer Science (ETCS), 2010 Second International Workshop on","6-7 March 2010","2010","3","","220","223","Legacy System is difficult to be maintained and refactored for lack of necessary documents and source codes. How to generate some valuable information from system runtime behaviors is a big challenge to systems reengineering. In this paper, we attempt to reconstruct class diagram and sequence diagram from the binary bytecode of Java program by reflection and bytecode decompilation. The pattern of Aspect-Oriented Programming is applied to resolve the intricate codes of Interface and Dependency Injection pattern through weaving aspect codes into binary bytecodes during runtime to trace the system behaviors. The experiments show our approach can exactly generate the class diagram and sequence diagram from legacy Java System.","","978-1-4244-6388-6","978-1-4244-6389-3","10.1109/ETCS.2010.298","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5459990","Aspect-Oriented Programming;Java Legacy System;Reengineering;Runtime Behavior;component","Computer science education;Java;Lamps;Pattern analysis;Programming profession;Reflection;Runtime;Systems engineering education;Unified modeling language;Weaving","Java;object-oriented programming;program compilers;reverse engineering;software maintenance;systems re-engineering","Java legacy system reengineering;Java program;aspect code weaving;aspect-oriented programming;binary bytecodes;bytecode decompilation;class diagram reconstruction;dependency injection pattern;sequence diagram reconstruction;system maintenance;system refactoring;system runtime behavior tracing","","","","1","","12","","","20100506","","IEEE","","IEEE Conference Publications","","","Dec. 14, 2013 1:37 PM EST","Dec. 14, 2013 1:37 PM EST"
"Recovering class diagrams from data-intensive legacy systems","Di Lucca, G.A.; Fasolino, A.R.; De Carlini, U.","Dipt. di Inf. e Sistemistica, Univ. di Napoli Federico II, Naples, Italy","Software Maintenance, 2000. Proceedings. International Conference on","2000","2000","","","52","63","Several reverse engineering methods for recovering objects from legacy systems have been proposed in the literature, but most of them neglect to identify the relationships among the objects, or recover only a part of them. The paper describes a method for recovering an OO (object oriented) model together with the objects and relationships among them. The proposed approach integrates the results of reverse engineering of both the procedural code and the persistent data stores of the system, and exploits a number of heuristic criteria to obtain a class diagram. A preliminary experiment carried out to validate the method on a COBOL medium-sized system yielded encouraging results","1063-6773","0-7695-0753-0","","10.1109/ICSM.2000.883005","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=883005","","Software maintenance","data handling;object-oriented programming;persistent objects;reverse engineering;software maintenance;system recovery","COBOL medium-sized system;OO model;class diagram;class diagram recovery;data-intensive legacy systems;heuristic criteria;object oriented model;object recovery;persistent data stores;procedural code;reverse engineering;reverse engineering methods","","","","3","","17","","","20020806","11 Oct 2000-14 Oct 2000","IEEE","","IEEE Conference Publications","","","Dec. 14, 2013 1:37 PM EST","Dec. 14, 2013 1:37 PM EST"
"Extraction and use of class dependency information for Java","Barowski, L.A.; Cross, J.H., II","Dept. Comput. Sci. & Software Eng., Auburn Univ., AL, USA","Reverse Engineering, 2002. Proceedings. Ninth Working Conference on","2002","2002","","","309","315","In this paper, a method for extracting class dependency information from Java class files is described. Advantages and disadvantages of using this method are discussed The problems of virtual dependence and synthetic methods are explained, and solutions offered. A convenient user interface is presented for making use of the dependency information in the form of an interactive UML class diagram, which is automatically generated from Java class files. This interface is a component of the jGRASP integrated development environment.","1095-1350","0-7695-1799-4","","10.1109/WCRE.2002.1173088","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1173088","","Computer science;Data mining;Displays;Java;Software engineering;Software systems;Terminology;Testing;Unified modeling language;User interfaces","Java;inheritance;object-oriented programming;specification languages;user interfaces","Java class files;class dependency information extraction;interactive UML class diagram;jGRASP integrated development environment;synthetic methods;user interface;virtual dependence","","","","5","1","","","","20030129","","IEEE","","IEEE Conference Publications","","","Dec. 14, 2013 1:37 PM EST","Dec. 14, 2013 1:37 PM EST"
"Runtime Checking of UML Association-Related Constraints","Kun Wang; Wuwei Shen","Western Michigan Univ. Kalamazoo, Kalamazoo","Dynamic Analysis, 2007. WODA '07. Fifth International Workshop on","20-26 May 2007","2007","","","3","3","UML class models are important design artifacts used as blueprints of software systems to be built. Yet, implementations are often inconsistent with their models. Although many techniques have been proposed to tackle this problem, some dynamic aspects of a class model are still hard to be verified using existing techniques. In this paper, we present an approach to checking the UML association-related constraints during a program's execution. Our approach instruments event notification mechanism into Java bytecode and verifies the constraints imposed by design-level associations (including compositions), when certain events occur. The empirical studies show that our approach can help efficiently detect inconsistencies between a UML class model and its implementation.","","0-7695-2963-1","","10.1109/WODA.2007.8","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4273460","","Computer science;Instruments;Java;Programming;Reverse engineering;Runtime;Software design;Software systems;Systems engineering and theory;Unified modeling language","Java;Unified Modeling Language;program verification","Java bytecode;UML association-related constraint;event notification mechanism;program execution;program verification;runtime checking","","","","0","","19","","","20070716","","IEEE","","IEEE Conference Publications","","","Dec. 14, 2013 1:37 PM EST","Dec. 14, 2013 1:37 PM EST"
"Applying pantomime and reverse engineering techniques in software engineering education","Pavlov, Vladimir L.; Boyko, N.; Babich, A.; Kuchaiev, O.; Busygin, S.","Int. Software & Productivity Eng. Inst., Lake Success","Frontiers In Education Conference - Global Engineering: Knowledge Without Borders, Opportunities Without Passports, 2007. FIE '07. 37th Annual","10-13 Oct. 2007","2007","","","T1E-1","T1E-5","During the past six years, the authors have experimented with various modeling and quality control techniques while teaching software engineering to university students. The first group of experiments compared UML to natural languages (e.g. english); the second group modeled the entire software development process as a sequence of translations from more abstract languages to more formal languages (e.g. from english to UML, from UML to C++, etc.). In these experiments the authors and their students discovered new approaches to increasing productivity of software developers. On this basis, the authors have developed the framework that extends traditional development processes. The framework is built upon two simple, yet powerful principles: reverse semantic traceability (RST) and speechless modeling. The authors have over two years of experience of using RST in computing curricula, and also have over six years of experience of applying speechless Modeling in teaching computer science and software engineering. Both approaches resulted in improving the quality of education and generated positive feedback from students. Some students started to practice the authors' framework in their professional careers. In this paper, the authors present their experience of integrating RST and speechless modeling into university computer science/software engineering curricula.","0190-5848","978-1-4244-1083-5","978-1-4244-1084-2","10.1109/FIE.2007.4418054","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4418054","Pantomime;Reverse Semantic Traceability;Software Engineering Curricula;Speechless modeling","Computer science;Control engineering education;Formal languages;Natural languages;Productivity;Programming;Quality control;Reverse engineering;Software engineering;Unified modeling language","Unified Modeling Language;computer science education;formal languages;natural languages;quality control;software engineering","UML;natural language;pantomime;quality control technique;reverse engineering technique;reverse semantic traceability;software development process;software engineering education;speechless modeling","","","","1","","7","","","20080104","","IEEE","","IEEE Conference Publications","","","Dec. 14, 2013 1:37 PM EST","Dec. 14, 2013 1:37 PM EST"
"An investigation: reengineering sequential procedure-driven software into object-oriented event-driven software through UML diagrams","Millham, R.","","Computer Software and Applications Conference, 2002. COMPSAC 2002. Proceedings. 26th Annual International","2002","2002","","","731","733","Reengineering a COBOL legacy system is a difficult multi-step process, particularly when the COBOL legacy system is a sequential procedural-driven system which is being reengineered into an object oriented, event-driven system. In this scenario, it is necessary to analyse the legacy system in order to identify possible objects with their attributes and methods within the code and to determine how the legacy system's variables and procedures interrelate in order to model pseudo-events from strictly sequential code. The focus of reengineering is too often based on theory rather than based on experience gained from real-world examples. This paper hopes to address this imbalance by providing a practical application of reengineering to an actual legacy telecommunications system.","0730-3157","0-7695-1727-7","","10.1109/CMPSAC.2002.1045088","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1045088","","Business communication;Communication switching;Communication system software;Companies;Cost function;Documentation;Object oriented modeling;Reverse engineering;System testing;Unified modeling language","COBOL;object-oriented programming;specification languages;systems re-engineering;telecommunication computing","COBOL legacy system;UML diagrams;legacy telecommunications system;object-oriented event-driven software;pseudo-event modeling;sequential code;sequential procedure-driven software reengineering","","","","2","","6","","","20021210","","IEEE","","IEEE Conference Publications","","","Dec. 14, 2013 1:37 PM EST","Dec. 14, 2013 1:37 PM EST"
"Reverse software engineering with UML for Web site maintenance","Sam Chung; Yun-Sik Lee","Dept. of Sci. & Math., Texas Univ., Odessa, TX, USA","Web Information Systems Engineering, 2000. Proceedings of the First International Conference on","2000","2000","2","","157","161 vol.2","It is shown that reverse software engineering using the Unified Process (UP) and visual models with the Unified Modeling Language can be applied to Web site maintenance. By reverse engineering the current Web sites, the implementation models of the current Web sites are derived from the Web sites. For the navigation schemes, the Web elements and their dependencies of the current Web sites are shown in component diagrams. Also, the physical directory structures are shown in the component view of the implementation model. Our empirical results on official university Web site maintenance show that the reverse software engineering and visual models can help Web administrators to understand the navigation schemes and physical structures quickly and easily","","0-7695-0577-5","","10.1109/WISE.2000.882874","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=882874","","Computer industry;Java;Navigation;Personnel;Reverse engineering;Software engineering;Software maintenance;Software systems;Unified modeling language;Web pages","educational technology;information resources;reverse engineering;software maintenance;specification languages;visual programming","UML;UP;Unified Modeling Language;Unified Process;Web administrators;Web elements;Web site maintenance;component diagrams;component view;implementation model;navigation schemes;official university Web sites;physical directory structures;reverse software engineering;visual models","","","","1","","9","","","20020806","19 Jun 2000-21 Jun 2000","IEEE","","IEEE Conference Publications","","","Dec. 14, 2013 1:37 PM EST","Dec. 14, 2013 1:37 PM EST"
"Reverse engineering of the interaction diagrams from C++ code","Tonella, P.; Potrich, A.","Centro per la Ricerca Scientifica e Tecnologica, ITC-irst, Povo, Italy","Software Maintenance, 2003. ICSM 2003. Proceedings. International Conference on","22-26 Sept. 2003","2003","","","159","168","In object oriented programming, the functionalities of a system result from the interactions (message exchanges) among the objects allocated by the system. While designing object interactions is far more complex than designing the object structure in forward engineering, the problem of understanding object interactions during code evolution is even harder, because the related information is spread across the code. In this paper, a technique for the automatic extraction of UML interaction diagrams from C++ code is proposed. The algorithm is based on a static, conservative flow analysis that approximates the behavior of the system in any execution and for any possible input. Applicability of the approach to large software is achieved by means of two mechanisms: partial analysis and focusing. Usage of our method on a real world, large C++ system confirmed its viability.","1063-6773","0-7695-1905-9","","10.1109/ICSM.2003.1235418","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1235418","","Algorithm design and analysis;Collaborative work;Data mining;Design engineering;Information analysis;Object oriented programming;Reverse engineering;Software maintenance;Systems engineering and theory;Unified modeling language","C++ language;message passing;object-oriented programming;program diagnostics;reverse engineering;specification languages","C++ code;UML interaction diagrams;automatic extraction;code evolution;conservative flow analysis;focusing mechanism;message exchange;object interactions;object oriented programming;partial analysis;reverse engineering;static flow analysis","","","","16","4","17","","","20031007","","IEEE","","IEEE Conference Publications","","","Dec. 14, 2013 1:37 PM EST","Dec. 14, 2013 1:37 PM EST"
"Design Pattern Mining from Source Code for Reverse Engineering","Basu, N.; Chatterjee, S.; Chaki, N.","Salt Lake Electron. Complex, NUT Technol. Ltd., Kolkata","TENCON 2005 2005 IEEE Region 10","21-24 Nov. 2005","2005","","","1","7","Design patterns are micro architectures that have proved to be reliable, easy-to implement and robust. There is a need in science and industry for recognizing these patterns. This paper aims toward development of a new method for discovering design patterns in the source codes. The method provides a precise specification of how the patterns work by describing basic structural information like inheritance, composition, aggregation and association, and as an indispensable part, by defining call delegation, object creation and operation overriding. We have tried to introduce a new XML-based language, the extensible pattern markup language XPML, which provides an easy way for the users to modify pattern descriptions to suit their needs, or even to define their own patterns or just classes in certain relations they wish to find. The proposed method is tested on four open-source systems, and is found to be effective in discovering design pattern instances.","","0-7803-9311-2","0-7803-9312-0","10.1109/TENCON.2005.301336","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4085136","Design patterns;Reverse Engineering Engine;Unified Modeling Language (UML);XML","Computer architecture;Computer science;Information technology;Markup languages;Pattern recognition;Reverse engineering;Software measurement;Software systems;Unified modeling language;XML","XML;data mining;formal specification;inheritance;object-oriented programming;reverse engineering;software architecture","XML-based language;XPML;aggregation;association;call delegation;composition;design pattern discovery;design pattern mining;extensible pattern markup language;inheritance;object creation;operation overriding;pattern definition;pattern description modification;pattern recognition;reverse engineering;software microarchitecture;source code;structural information","","","","0","","17","","","20070205","","IEEE","","IEEE Conference Publications","","","Dec. 14, 2013 1:37 PM EST","Dec. 14, 2013 1:37 PM EST"
"Reverse engineering of object oriented code","Tonella, P.","Centro per la Ricerca Scientifica e Tecnologica, ITC-IRST, Trento, Italy","Software Engineering, 2005. ICSE 2005. Proceedings. 27th International Conference on","15-21 May 2005","2005","","","724","725","During software evolution, programmers devote most of their effort to the understanding of the structure and behavior of the system. For object oriented code, this might be particularly hard, when multiple, scattered objects contribute to the same function. Design views offer an invaluable help, but they are often not aligned with the code, when they are not missing at all. This tutorial describes some of the most advanced techniques that can be employed to reverse engineer several design views from the source code. The recovered diagrams, represented in UML (Unified Modeling Language), include class, object, interaction (collaboration and sequence), state and package diagrams. A unifying static code analysis framework used by most of the involved algorithms is presented at the beginning of the tutorial. A single running example is referred all over the presentation. Trade-offs (e.g., static vs. dynamic analysis), limitations and expected benefits are also discussed.","","1-59593-963-2","","10.1109/ICSE.2005.1553682","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1553682","","Algorithm design and analysis;Collaboration;Object oriented programming;Packaging;Programming profession;Reverse engineering;Scattering;Software engineering;Software maintenance;Unified modeling language","object-oriented programming;program diagnostics;reverse engineering","diagram recovery;object oriented code;object oriented programming;reverse engineering;static code analysis","","","","3","","1","","","20051219","","IEEE","","IEEE Conference Publications","","","Dec. 14, 2013 1:37 PM EST","Dec. 14, 2013 1:37 PM EST"
"Reverse Engineering State Machines by Interactive Grammar Inference","Walkinshaw, N.; Bogdanov, K.; Holcombe, M.; Salahuddin, S.","Regent Court, Sheffield","Reverse Engineering, 2007. WCRE 2007. 14th Working Conference on","28-31 Oct. 2007","2007","","","209","218","Finite state machine-derived specifications such as X-machines, extended finite state machines and abstract state machines, are an established means to model software behaviour. They allow for comprehensive testing of an implementation in terms of its intended behaviour. In practice however they are rarely generated and maintained during software development, hence their benefits can rarely be exploited. We address this problem by using an interactive grammar inference technique to infer the underlying state machine representation of an existing software system. The approach is interactive because it generates queries to the user as it constructs a hypothesis machine, which can be interpreted as system tests. This paper describes (1) how an existing grammar inference technique (QSM) can be used to reverse-engineer state-based models of software from execution traces at a developer-defined level of abstraction and (2) how the QSM technique can be improved for a better balance between the number of tests it proposes and the accuracy of the machine it derives. The technique has been implemented, which has enabled us to present a small case study of its use with respect to a real software system, along with some preliminary performance results.","1095-1350","978-0-7695-3034-5","","10.1109/WCRE.2007.45","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4400167","","Automata;Automatic testing;Electronic mail;Programming;Reverse engineering;Software engineering;Software maintenance;Software systems;Software testing;System testing","finite state machines;formal specification;grammars;program verification;reverse engineering","X-machines;abstract state machines;extended finite state machines;finite state machine-derived specifications;hypothesis machine;interactive grammar inference;reverse engineering state machines;software behaviour modeling","","","","9","","23","","","20071210","","IEEE","","IEEE Conference Publications","","","Dec. 14, 2013 1:37 PM EST","Dec. 14, 2013 1:37 PM EST"
"Model Transformation Specification and Verification","Lano, K.; Clark, D.","Dept. of Comput. Sci., King''s Coll. London, London","Quality Software, 2008. QSIC '08. The Eighth International Conference on","12-13 Aug. 2008","2008","","","45","54","Model transformations are becoming increasingly important in software development, particularly as part of model-driven development approaches (MDD). This paper defines an approach for specifying transformations as constraints, and for verifying the correctness of these transformations.","1550-6002","978-0-7695-3312-4","","10.1109/QSIC.2008.38","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4601527","Model transformations;Specification;UML","Computer science;Educational institutions;Java;Packaging;Programming;Reverse engineering;Software quality;Standards development;Unified modeling language","formal specification;formal verification;software architecture","formal specification;formal verification;model transformation;model-driven development approach;software development","","","","2","","14","","","20080819","","IEEE","","IEEE Conference Publications","","","Dec. 14, 2013 1:37 PM EST","Dec. 14, 2013 1:37 PM EST"
"A Matrix-Based Approach to Recovering Design Patterns","Jing Dong; Yajing Zhao; Yongtao Sun","Dept. of Comput. Sci., Univ. of Texas at Dallas, Richardson, TX, USA","Systems, Man and Cybernetics, Part A: Systems and Humans, IEEE Transactions on","Nov. 2009","2009","39","6","1271","1282","Design patterns describe good solutions to common and recurring problems in software design. They have been widely applied in many software systems in industry. However, pattern-related information is typically not available in large system implementations. Recovering these design pattern instances in software systems can help not only to understand the original design decisions and tradeoffs but also to change the systems with quality assurance. This paper presents our approach on recovering design patterns based on matrices and weights. We formally specify our methods to encode both the systems and the design patterns into matrices and weight. Our formal specification rigorously defines the structural, behavioral, and semantic analyses of our approach. A set of experiments on real-world systems is also carried out to evaluate our approach with analysis results.","1083-4427","","","10.1109/TSMCA.2009.2028012","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5256246","Design pattern;Extensible Markup Language (XML);Unified Modeling Language (UML);reverse engineering","","formal specification;matrix algebra;software architecture","behavioral analysis;formal specification;matrix-based approach;quality assurance;recovering design patterns;semantic analyses;software design;software systems;structural analysis","","","","4","","50","","2009-09-22","20091016","","IEEE","IEEE Systems, Man, and Cybernetics Society","IEEE Journals & Magazines","","","Dec. 14, 2013 1:37 PM EST","Dec. 14, 2013 1:37 PM EST"
"JCHVT: A kind of software visualization method for Java Code","Guoqiang Wang; Changzhen Hu; Zhigang Wang; Jun Zhen; Zhongyang Kan","Lab. of Comput. Network Defense Technol., Beijing Inst. of Technol., Beijing, China","Computer Application and System Modeling (ICCASM), 2010 International Conference on","22-24 Oct. 2010","2010","2","","V2-110","V2-113","Java Code Hierarchical Visualization Tool (JCHVT) is a software visualization system oriented to Java source code, which has been designed on the concept of service and with reference to Class diagram and Polymetric view. JCHVT is able to automatically create a hierarchical view of the software system, which can reflect the relationships among classes, structure of the system and even the roles of classes played in the system. Meanwhile, JCHVT provides various methods of human-computer interactions which can help user to understand the graph and identify the useful information in the view.","","978-1-4244-7235-2","978-1-4244-7237-6","10.1109/ICCASM.2010.5620081","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5620081","Java code;class diagram;hierarchical view of system structure;software visualization","Color;Erbium;Internet;Software;Visualization","Java;data visualisation;human computer interaction;reverse engineering;software tools","JCHVT;Java code hierarchical visualization tool;class diagram;graph;hierarchical view;human-computer interactions;polymetric view;software system;software visualization","","","","0","","10","","","20101104","","IEEE","","IEEE Conference Publications","","","Dec. 14, 2013 1:37 PM EST","Dec. 14, 2013 1:37 PM EST"
"A systematic study of UML class diagram constituents for their abstract and precise recovery","Gue&#x0301;he&#x0301;neuc, Y.","Dept. d''Inf. et de Recherche Oper., Montreal Univ., Que., Canada","Software Engineering Conference, 2004. 11th Asia-Pacific","30 Nov.-3 Dec. 2004","2004","","","265","274","Existing reverse-engineering tools use algorithms based on vague and verbose definitions of UML constituents to recover class diagrams from source code. Thus, reverse-engineered class diagrams are neither abstract nor precise representations of source code and are of little interest for software engineers. We propose an exhaustive study of class diagram constituents with respect to their recovery from C++, Java, and Smalltalk source code. We exemplify our study with a tool suite, PTIDEJ, to reverse-engineer Java programs as UML class diagrams abstractly and precisely. The tool suite produces class diagrams that help software engineers in better understanding programs.","1530-1362","0-7695-2245-9","","10.1109/APSEC.2004.13","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1371928","","Computer architecture;Design engineering;Impedance;Java;Maintenance engineering;Reverse engineering;Software engineering;Software maintenance;Software tools;Unified modeling language","C++ language;Java;Smalltalk;Unified Modeling Language;reverse engineering;software tools","C++;Java;Ptidej tool;Smalltalk source code;UML;UML class diagram;abstract;precise recovery;reverse-engineering tool;software engineer;vague;verbose definition","","","","3","","24","","","20050117","","IEEE","","IEEE Conference Publications","","","Dec. 14, 2013 1:29 PM EST","Dec. 14, 2013 1:29 PM EST"
"Program comprehension: A method of generating visualized UML class diagram","GuHui; WangHui","College of Computer Science and Technology, Zhejiang University of Technology, ZJUT, Hangzhou, China","Information Science and Engineering (ICISE), 2010 2nd International Conference on","4-6 Dec. 2010","2010","","","6775","6776","Program comprehension is an important research content of software engineering. This paper presents a Program comprehension visualization method of using UML class diagram. This method has two parts, first, The program source code is abstracted into database table, the form used to summarize and express program structure and key information, Then, the table was transformed into UML class diagrams, The class diagram can be effective to help understanding program structure and other key information.","","978-1-4244-7616-9","","10.1109/ICISE.2010.5690312","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5690312","UML class diagram;program comprehension;table abstract;visualization","Educational institutions;Software engineering;Software maintenance;Unified modeling language;Visualization","","","","","","0","","4","","","20110117","","IEEE","","IEEE Conference Publications","","","Dec. 14, 2013 1:29 PM EST","Dec. 14, 2013 1:29 PM EST"
"Reverse engineering of the UML class diagram from c++ code in presence of weakly typed containers","Tonella, P.; Potrich, A.","Centro per la Ricerca Scientifica e Tecnologica, ITC-irst, Trento, Italy","Software Maintenance, 2001. Proceedings. IEEE International Conference on","2001","2001","","","376","385","UML diagrams, and in particular the most frequently used one, the class diagram, represent a valuable source of information even after the delivery of the system, when it enters the maintenance phase. Several tools provide a reverse engineering engine to recover it from the code. In this paper an algorithm is proposed for the improvement of the accuracy of the UML class diagram extracted from the code. Specifically, important information about inter-class relations may be missed in a reverse engineered class diagram, when weakly typed containers, i.e., containers collecting objects whose type is the top of the inheritance hierarchy, are employed. In fact, the class of the contained objects is not directly known, and therefore no relation with it is apparent from the container declaration. The proposed approach was applied to several software components developed at CERN. Experimental results highlight that a substantial improvement is achieved when the container type information is refined with the inferred data. The number of relations otherwise missed is relevant and the connectivity of the associated class diagrams is radically different when containers are considered","1063-6773","0-7695-1189-9","","10.1109/ICSM.2001.972750","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=972750","","Collaborative work;Computer languages;Containers;Data mining;Engines;Information resources;Java;Libraries;Reverse engineering;Unified modeling language","C++ language;reverse engineering;software maintenance;specification languages","C++ code;UML class diagram;inter-class relations;reverse engineering;weakly typed containers","","","","8","","14","","","20020806","07 Nov 2001-09 Nov 2001","IEEE","","IEEE Conference Publications","","","Dec. 14, 2013 1:29 PM EST","Dec. 14, 2013 1:29 PM EST"
"Towards an AST-Based Approach to Reverse Engineering","Wang, Xin; Xiaojie Yuan","Coll. of Inf. Tech. Sci., Nankai Univ., Tianjin","Electrical and Computer Engineering, 2006. CCECE '06. Canadian Conference on","May 2006","2006","","","422","425","Today, it is recognized that reverse-engineering activities play an important role in round-trip development and software maintenance. However, the precision of most existing reverse-engineering tools cannot meet the requirements of developers and maintainers, thus hampering understanding of software implementation. This paper presents an approach for recovering the UML class diagram from the Java source code, which traverses abstract syntax trees (AST) with the visitor pattern to build the corresponding UML model elements. The source code is completely and systematically analyzed by this approach. As a result, the precision of the generated design model will be substantially promoted","","1-4244-0038-4","1-4244-0038-4","10.1109/CCECE.2006.277552","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4054609","AST;Reverse engineering;UML model","Computer aided software engineering;Design engineering;Educational institutions;Java;Reverse engineering;Software design;Software maintenance;Software tools;Tree data structures;Unified modeling language","Java;Unified Modeling Language;abstract data types;computer aided software engineering;reverse engineering;software maintenance;software tools;tree data structures","AST-based approach;Java source code;UML class diagram;abstract syntax trees;design model;reverse engineering;round-trip development;software implementation;software maintenance;visitor pattern","","","","0","","6","","","20070115","","IEEE","","IEEE Conference Publications","","","Dec. 14, 2013 1:29 PM EST","Dec. 14, 2013 1:29 PM EST"
"The case for reverse engineering","Blaha, M.R.","OMT Associates Inc., USA","IT Professional","Mar/Apr 1999","1999","1","2","35","41","It may seem hard to choose between two software products, but studying their databases can reveal a clear winner and save you years of grief. The most productive way to reverse engineer a database is to build a model that conveys the software's scope and intent. For a clean database, you'll most likely want to prepare a model; for a flawed and poorly documented database, it may be best to stop after studying the style and quality of the database structure. At OMT Associates, we generally construct models-usually expressed as Unified Modeling Language (UML) object models. We typically organize reverse engineering into three phases-implementation recovery, design recovery, and analysis recovery. Reverse engineering is more than just a process for studying databases; it has profound implications for software development in general. You might view the reverse engineering of vendor databases as a creative response to the so-called software crisis. The current approach of preaching methodology and discipline isn't working, Software quality and development productivity still badly lag behind our desires. Database reverse engineering gives us both a carrot and a stick. The flaws and excellence of various products become more obvious and more heavily influence product success and failure. For a large corporation, the cost of the evaluation (as little as a few person-weeks) is trivial compared to the millions spent buying and deploying new software","1520-9202","","","10.1109/6294.774939","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=774939","","Computer aided software engineering;Design engineering;Design optimization;Documentation;Object oriented databases;Object oriented modeling;Relational databases;Reverse engineering;Solids;User interfaces","database management systems;reverse engineering;software quality;software selection","UML object models;Unified Modeling Language;analysis recovery;database structure;design recovery;development productivity;implementation recovery;large corporation;product success;reverse engineering;software crisis;software development;software product selection;software quality;vendor databases","","","","4","","","","","20020806","","IEEE","IEEE Computer Society","IEEE Journals & Magazines","","","Dec. 14, 2013 1:29 PM EST","Dec. 14, 2013 1:29 PM EST"
"Object naming analysis for reverse-engineered sequence diagrams","Rountev, A.; Connell, B.H.","Dept. of Comput. Sci. & Eng., Ohio State Univ., USA","Software Engineering, 2005. ICSE 2005. Proceedings. 27th International Conference on","15-21 May 2005","2005","","","254","263","UML sequence diagrams are commonly used to represent object interactions in software systems. This paper considers the problem of extracting UML sequence diagrams from existing code for the purposes of software understanding and testing. A static analysis for such reverse engineering needs to map the interacting objects from the code to sequence diagram objects. We propose an interprocedural dataflow analysis algorithm that determines precisely which objects are the receivers of certain messages, and assigns the appropriate diagram objects to represent them. Our experiments indicate that the majority of message receivers can be determined exactly, resulting in highly-precise object naming for reverse-engineered sequence diagrams.","","1-59593-963-2","","10.1109/ICSE.2005.1553568","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1553568","","Algorithm design and analysis;Computer science;Java;Logic programming;Permission;Reverse engineering;Runtime;Software maintenance;Software testing;Unified modeling language","Unified Modeling Language;data flow analysis;object-oriented programming;program testing;reverse engineering;systems analysis","UML sequence diagrams;interprocedural dataflow analysis;object naming analysis;reverse-engineered sequence diagrams;software testing;software understanding;static analysis","","","","10","","21","","","20051219","","IEEE","","IEEE Conference Publications","","","Dec. 14, 2013 1:29 PM EST","Dec. 14, 2013 1:29 PM EST"
"A simple static model for understanding the dynamic behavior of programs","Kelsen, P.","Fac. of Sci., Technol. & Commun., Luxembourg Univ., Kirchberg, Luxembourg","Program Comprehension, 2004. Proceedings. 12th IEEE International Workshop on","24-26 June 2004","2004","","","46","51","To maintain software and to adapt it to changing requirements, one needs to have a solid understanding of both its structure and behavior. While there are a number of reverse engineering tools that aid in understanding the runtime behavior of programs, these are mostly based on variants of UML sequence diagrams or statechart diagrams. We propose a new model for understanding runtime behavior that presents several advantages over the more traditional models: it has a simple syntax (a very small subset of UML). Second one can tailor the same type of model to different abstraction levels while maintaining traceability. Third, they have a clearly defined semantics that makes them executable. Finally they capture both static and dynamic aspects of a system. We present three scenarios where our model - named EOP-model - aids with program comprehension: (1) high-level debugging, with which one can observe the execution of the program at a higher level of abstraction; (2) high-level program slicing, which allows to identify the data items in our model that may influence an operation, regardless of the abstraction level, and (3) generating abstract views at varying levels of detail while maintaining traceability between model elements and the code.","1092-8138","0-7695-2149-5","","10.1109/WPC.2004.1311046","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1311046","","Communications technology;Conferences;Data mining;Debugging;Educational programs;Reverse engineering;Runtime;Software maintenance;Unified modeling language;Visualization","Unified Modeling Language;program debugging;program slicing;reverse engineering;software maintenance","EOP-model;UML sequence diagrams;high-level debugging;program comprehension;program dynamic behavior;program slicing;program understanding;reverse engineering;software maintenance;statechart diagrams","","","","1","","16","","","20040712","","IEEE","","IEEE Conference Publications","","","Dec. 14, 2013 1:29 PM EST","Dec. 14, 2013 1:29 PM EST"
"Recovering Concepts from Source Code with Automated Concept Identification","Carey, M.M.; Gannod, G.C.","Dept. of Comput. Sci. & Eng., Arizona State Univ., Tempe, AZ","Program Comprehension, 2007. ICPC '07. 15th IEEE International Conference on","26-29 June 2007","2007","","","27","36","The complexity of the systems that software engineers build has continuously grown since the inception of the field. What has not changed is the engineers' mental capacity to operate on about seven distinct pieces of information at a time. Improvements like the widespread use of UML have led to more abstract software design activities, however the same cannot be said for reverse engineering activities. The well known concept assignment problem is still being solved at the line-by-line level of analyzing source code. The introduction of abstraction to the problem will allow the engineer to move farther away from the details of the system, increasing his ability to see the role that domain level concepts play in the system. In this paper we present a technique that facilitates filtering of classes from existing systems at the source level based on their relationship to the core concepts in the domain. This approach can simplify the process of reverse engineering and design recovery, as well as other activities that require a mapping to domain level concepts.","1092-8138","0-7695-2860-0","","10.1109/ICPC.2007.31","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4268238","","Computer science;Engineering profession;Filtering;Machine learning;Psychology;Reverse engineering;Software design;Software systems;Systems engineering and theory;Unified modeling language","Unified Modeling Language;reverse engineering;software metrics","UML;automated concept identification;reverse engineering activity;software design activity;software engineer;software metric;source code","","","","6","","22","","","20070709","","IEEE","","IEEE Conference Publications","","","Dec. 14, 2013 1:29 PM EST","Dec. 14, 2013 1:29 PM EST"
"Research on Reverse Engineering from Formal Models to UML Models","Wei Yan; Yugen Du","Software Eng. Inst., East China Normal Univ., Shanghai, China","Parallel Architectures, Algorithms and Programming (PAAP), 2010 Third International Symposium on","18-20 Dec. 2010","2010","","","406","411","The Unified Modeling Language (UML) provides a graphical notation to express the design of object-oriented software systems and has become the de facto industry standard for software design. However UML lacks precise semantics and is semi-formal. Formal specification languages are intended to provide precise and complete models for proposed software systems. Many researchers have done a lot of work in translating UML models into formal models to validate UML models. But in this paper, we discuss the reverse engineering problem, that is, when the formal models are validated and corrected, how to reverse them to UML models. We think this problem is more meaningful for software engineer. This paper presents a method that translates formal models into UML models by XMI and its Schema, and then testifies the feasibility and correctness of the reverse method by Unifying Theories of Programming (UTP).","","978-1-4244-9482-8","","10.1109/PAAP.2010.54","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5715116","UML;UTP;formal method;reverse transformation","Analytical models;Cognition;Mathematical model;Noise measurement;Object oriented modeling;Semantics;Unified modeling language","Unified Modeling Language;formal specification;object-oriented programming;reverse engineering","UML models;de facto industry standard;formal specification languages;object-oriented software systems;reverse engineering","","","","0","","50","","","20110217","","IEEE","","IEEE Conference Publications","","","Dec. 14, 2013 1:29 PM EST","Dec. 14, 2013 1:29 PM EST"
"Application of UML associations and their adornments in design recovery","Kollmann, R.; Gogolla, M.","Dept. of Comput. Sci., Bremen Univ., Germany","Reverse Engineering, 2001. Proceedings. Eighth Working Conference on","2001","2001","","","81","90","Many CASE tools support reverse engineering and UML. However, it can be observed that, usually, only a subset of the UML notation is supported, namely those parts with a more or less direct code representation. Although a lot of research has been done in this field, the more advanced features of UML notations are not commonly supported in reverse engineering. In this paper, we show approaches to discover patterns in program code that can be represented by means of the advanced notational features of UML class diagrams. We obtain the necessary information by reverse-engineering Java programs with different methods. These have been implemented in a prototype implementation","1095-1350","0-7695-1303-4","","10.1109/WCRE.2001.957812","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=957812","","Application software;Computer aided software engineering;Computer science;Handicapped aids;Java;Marine vehicles;Prototypes;Reverse engineering;Software prototyping;Unified modeling language","Java;computer aided software engineering;diagrams;reverse engineering;software prototyping;specification languages","CASE tools;Java programs;UML associations;UML class diagrams;UML notations;adornment;composition;direct code representation;prototype implementation;reverse engineering;system design recovery","","","","6","","","","","20020807","02 Oct 2001-05 Oct 2001","IEEE","","IEEE Conference Publications","","","Dec. 14, 2013 1:29 PM EST","Dec. 14, 2013 1:29 PM EST"
"CPP2XMI: Reverse Engineering of UML Class, Sequence, and Activity Diagrams from C++ Source Code","Korshunova, E.; Petkovic, M.; van den Brand, M.G.J.; Mousavi, M.R.","Lab. for Quality Software, Technische Universiteit Eindhoven","Reverse Engineering, 2006. WCRE '06. 13th Working Conference on","Oct. 2006","2006","","","297","298","In most cases, reverse engineering is used to retrieve missing design documentation from the source code in the form of an abstract (e.g., UML) model. In the context of this work, reverse engineering is used as a part of the verification and validation chain of software systems, where the static structure and the dynamic behavior of a system are derived from the source code and represented in XML Metadata Interchange (XMI) format. The obtained model is further analyzed for such characteristics as soundness and complexity of the system. XMI is a standard that enables us to express objects using Extensible Markup Language (XML). XMI can be used to represent objects from UML model in XML. In this paper, we describe a reverse engineering tool, CPP2XMI, which allows extracting UML class, sequence, and activity diagrams in XMI format from C++ source code, and its position in the toolset for software system analysis","1095-1350","0-7695-2719-1","","10.1109/WCRE.2006.21","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4024002","","Computer aided software engineering;Data mining;Information filtering;Information filters;Reverse engineering;Software systems;US Department of Transportation;Unified modeling language;Visualization;XML","C++ language;Unified Modeling Language;XML;program diagnostics;program verification;reverse engineering","C++ source code;CPP2XMI;Extensible Markup Language;UML activity diagram;UML class;UML sequence;XML Metadata Interchange;reverse engineering;software system analysis;software systems validation;software systems verification","","","","6","","7","","","20061211","","IEEE","","IEEE Conference Publications","","","Dec. 14, 2013 1:29 PM EST","Dec. 14, 2013 1:29 PM EST"
"Abstract and precise recovery of UML class diagram constituents","Gue&#x0301;he&#x0301;neuc, Y.","Departement d''Informatique et de Recherche Operationnelle, Univ. de Montreal, Que., Canada","Software Maintenance, 2004. Proceedings. 20th IEEE International Conference on","11-14 Sept. 2004","2004","","","523","","Reverse-engineered UML class diagrams are neither abstract nor precise representations of source code because of the loose definitions of UML constituents. Thus, they are of little interest for software maintainers. We perform an exhaustive study of UML class diagrams constituents with respect to their recovery from C++, Java, and Smalltalk source code. We implement a tool suite, Ptidej, to reverse engineer Java source code abstractly and precisely.","1063-6773","0-7695-2213-0","","10.1109/ICSM.2004.1357865","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1357865","","Concrete;Java;Notice of Violation;Reverse engineering;Sections;Software maintenance;Unified modeling language","C++ language;Java;Smalltalk;Unified Modeling Language;diagrams;reverse engineering;software maintenance;software tools","C++;Java;Ptidej;Smalltalk;UML class diagram constituent recovery;reverse-engineered UML class diagrams;software maintenance","","","","0","","","","","20041122","","IEEE","","IEEE Conference Publications","","","Dec. 14, 2013 1:29 PM EST","Dec. 14, 2013 1:29 PM EST"
"A study on the current state of the art in tool-supported UML-based static reverse engineering","Kollmann, R.; Selonen, P.; Stroulia, E.; Systa, T.; Zundorf, A.","Dept. of Comput. Sci., Bremen Univ., Germany","Reverse Engineering, 2002. Proceedings. Ninth Working Conference on","2002","2002","","","22","32","Today, software-engineering research and industry alike recognize the need for practical tools to support reverse-engineering activities. Most of the well-known CASE tools support reverse engineering in some way. The Unified Modeling Language (UML) has emerged as the de facto standard for graphically representing the design of object-oriented software systems. However, there does not yet exist a standard scheme for representing the reverse-engineered models of these systems. The various CASE tools usually adopt proprietary extensions to UML and, as a result, it is difficult, or even impossible, to ensure that model semantics remains unambiguous when working with different tools at the same time. In this paper, we examine the capabilities of the two most successful industrial-strength CASE-tools in reverse engineering the static structure of software systems and compare them to the results produced by two academic prototypes. The comparisons are carried out both manually and automatically using a research prototype for manipulating and comparing UML models.","1095-1350","0-7695-1799-4","","10.1109/WCRE.2002.1173061","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1173061","","Computer aided software engineering;Computer industry;Object oriented modeling;Prototypes;Reverse engineering;Software design;Software prototyping;Software standards;Software systems;Unified modeling language","computer aided software engineering;reverse engineering;specification languages","CASE tools;Unified Modeling Language;object-oriented software systems;tool-supported UML-based static reverse engineering","","","","17","","","","","20030129","","IEEE","","IEEE Conference Publications","","","Dec. 14, 2013 1:29 PM EST","Dec. 14, 2013 1:29 PM EST"
"UML-based reverse engineering and model analysis approaches for software architecture maintenance","Riva, C.; Selonen, P.; Systa, T.; Xu, J.","","Software Maintenance, 2004. Proceedings. 20th IEEE International Conference on","11-14 Sept. 2004","2004","","","50","59","This paper proposes a UML-based software maintenance process. The process is guided by architectural descriptions and existing architectural models. The descriptions are given as variants of UML profiles describing the styles and rules relevant for a particular application domain. A reverse engineering subprocess, combining top-down and bottom-up reverse engineering activities, aims at constructing the architectural models. Resulting models are investigated in a model analysis subprocess. The models are checked against the profiles to find violations against the given architectural rules when maintaining and developing the subject system, and they are further analyzed using a set of UML model processing operations. The proposed approach is applied for maintaining a large-scale product platform architecture and real-life product-line products built on top of this platform. The model analysis results of the case study are discussed.","1063-6773","0-7695-2213-0","","10.1109/ICSM.2004.1357789","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1357789","","Application software;Computer architecture;Data mining;Laboratories;Object oriented modeling;Reverse engineering;Software architecture;Software maintenance;Software systems;Unified modeling language","Unified Modeling Language;reverse engineering;software architecture;software maintenance","UML;architectural rules;architecture analysis;bottom-up reverse engineering;large-scale product platform architecture;real-life product-line products;software architecture;software maintenance;top-down reverse engineering","","","","5","1","16","","","20041122","","IEEE","","IEEE Conference Publications","","","Dec. 14, 2013 1:29 PM EST","Dec. 14, 2013 1:29 PM EST"
"Code querying by UML","Noguera, C.; De Roover, C.; Kellens, A.; Jonckers, V.","Software Languages Lab., Vrije Univ. Brussel, Brussels, Belgium","Program Comprehension (ICPC), 2012 IEEE 20th International Conference on","11-13 June 2012","2012","","","229","238","The need to identify source code that exhibits particular characteristics is essential to program comprehension. In this paper we introduce Arabica, a tool for querying Java code using UML class and sequence diagrams. Our use of UML diagrams avoids the need for developers to familiarize themselves with yet another language. In contrast to tools that rely on dedicated query languages, Arabica encodes querying semantics in a dedicated, minimal UML profile. Stereotyped class and sequence diagrams, characterizing structural and behavioral properties respectively, are translated into logic program queries. Using examples from the JHotDraw framework, we illustrate the utility of Arabica in validating design invariants, finding design pattern implementations and exploring extension points. We present a pre/post-test quasi experiment as a preliminary assessment of our approach.","1092-8138","978-1-4673-1213-4","978-1-4673-1215-8","10.1109/ICPC.2012.6240492","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6240492","","Concrete;Database languages;Java;Mice;Semantics;Syntactics;Unified modeling language","Java;Unified Modeling Language;query processing;reverse engineering","Arabica;JHotDraw framework;Java code querying;UML class;behavioral properties;logic program queries;pre-posttest quasi experiment;program comprehension;sequence diagrams;source code identification;stereotyped class;structural properties","","","","1","","27","","","20120716","","IEEE","","IEEE Conference Publications","","","Dec. 14, 2013 1:29 PM EST","Dec. 14, 2013 1:29 PM EST"
"Mappings for accurately reverse engineering UML class models from C++","Sutton, A.; Maletic, J.I.","Dept. of Comput. Sci., Kent State Univ., OH","Reverse Engineering, 12th Working Conference on","11-11 Nov. 2005","2005","","","10 pp.","184","The paper introduces a number of mapping rules for reverse engineering UML class models from C++ source code. The mappings focus on accurately identifying such elements as relationship types, multiplicities, and aggregation semantics. These mappings are based on domain knowledge of the C++ language and common programming conventions and idioms. An application implementing these heuristics is used to reverse engineer a moderately sized open source, C++ application, and the resultant class model is compared against those produced by other UML reverse engineering applications. A comparison shows that these presented mapping rules effectively produce meaningful, semantically accurate UML models","1095-1350","0-7695-2474-5","","10.1109/WCRE.2005.21","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1566157","","Application software;Computer architecture;Computer science;Libraries;Logic;Open source software;Reverse engineering;Software tools;Testing;Unified modeling language","C++ language;Unified Modeling Language;reverse engineering","C++ language application;C++ source code;UML class model;Unified Modeling Language;aggregation semantics;domain knowledge;open source;reverse engineering application","","","","3","","18","","","20060103","","IEEE","","IEEE Conference Publications","","","Dec. 14, 2013 1:29 PM EST","Dec. 14, 2013 1:29 PM EST"
"A Reverse-Engineering Approach to Understanding B Specifications with UML Diagrams","Idani, A.; Ledru, Y.; Bert, D.","Lab. Logiciels, Systemes, Univ. Joseph Fourier, Saint Martin d''Heres","Software Engineering Workshop, 2006. SEW '06. 30th Annual IEEE/NASA","April 2006","2006","","","97","106","Formal methods are nowadays the most rigorous way to produce software. However, the existing formal notations are not easy to use and understand for most people. Our approach proposes to circumvent this shortcoming by producing complementary graphical views on the formal developments. This paper addresses the graphical representation of formal B specifications using UML diagrams. A reverse-engineering approach is proposed to generate several class diagrams showing the static aspects of the B developments. These diagrams can help understand the specification for stakeholders who are not familiar with the B method, such as customers or certification authorities. A concept formation technique based on weighted link matrices is proposed to improve automation","1550-6215","0-7695-2624-1","","10.1109/SEW.2006.6","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4090250","B;Concept formation;Formal concept analysis.;UML","Application software;Automation;Certification;Documentation;Formal specifications;Programming;Rail transportation;Refining;Smart cards;Unified modeling language","Unified Modeling Language;formal specification;reverse engineering","B specifications;UML diagrams;class diagrams;concept formation technique;formal concept analysis;graphical representation;reverse-engineering approach;weighted link matrices","","","","1","","23","","","20070212","","IEEE","","IEEE Conference Publications","","","Dec. 14, 2013 1:29 PM EST","Dec. 14, 2013 1:29 PM EST"
"Toward the Reverse Engineering of UML Sequence Diagrams for Distributed Java Software","Briand, L.C.; Labiche, Y.; Leduc, J.","Dept. of Syst. & Comput. Eng., Carleton Univ., Ottawa, Ont.","Software Engineering, IEEE Transactions on","Sept. 2006","2006","32","9","642","663","This paper proposes a methodology and instrumentation infrastructure toward the reverse engineering of UML (Unified Modeling Language) sequence diagrams from dynamic analysis. One motivation is, of course, to help people understand the behavior of systems with no (complete) documentation. However, such reverse-engineered dynamic models can also be used for quality assurance purposes. They can, for example, be compared with design sequence diagrams and the conformance of the implementation to the design can thus be verified. Furthermore, discrepancies can also suggest failures in meeting the specifications. Due to size constraints, this paper focuses on the distribution aspects of the methodology we propose. We formally define our approach using metamodels and consistency rules. The instrumentation is based on aspect-oriented programming in order to alleviate the effort overhead usually associated with source code instrumentation. A case study is discussed to demonstrate the applicability of the approach on a concrete example","0098-5589","","","10.1109/TSE.2006.96","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1707665","AspectJ;OCL.;RMI;UML;distribution;reverse engineering;sequence diagram","Documentation;Information retrieval;Instruments;Java;Object oriented modeling;Quality assurance;Reverse engineering;Runtime;Testing;Unified modeling language","Java;Unified Modeling Language;formal specification;formal verification;object-oriented programming;program diagnostics;reverse engineering;software quality","UML sequence diagram;Unified Modeling Language;aspect-oriented programming;consistency rule;distributed Java software;dynamic program analysis;formal specification;formal verification;metamodel;quality assurance;reverse engineering;source code instrumentation","","","","47","","41","","","20061009","","IEEE","IEEE Computer Society","IEEE Journals & Magazines","","","Dec. 14, 2013 1:29 PM EST","Dec. 14, 2013 1:29 PM EST"
"An Approach for Reverse Engineering of Web Applications","Sun Weijun; Li Shixian; Liu Xianming","Dept. of Comput. Sci., SUN YAT-SEN Univ., Guangzhou","Information Science and Engineering, 2008. ISISE '08. International Symposium on","20-22 Dec. 2008","2008","2","","98","102","Web applications are the legacy software of the future. The Web application reverse-engineering process becomes necessary in order to facilitate the maintenance and evolution. This paper presents an approach to recover the architecture of web applications. The approach generates UML models from existing web applications through static and dynamic techniques. UML diagrams are extracted to depict the static, dynamic and behavioral aspect of Web applications. Finally, the architecture of the tool is described.","","978-1-4244-2727-4","","10.1109/ISISE.2008.86","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4732352","UML;Web application;legacy software;reverse engineering","","Internet;Unified Modeling Language;reverse engineering;software maintenance","UML models;Web applications;legacy software;reverse-engineering process","","","","2","","22","","","20081230","","IEEE","","IEEE Conference Publications","","","Dec. 14, 2013 1:29 PM EST","Dec. 14, 2013 1:29 PM EST"
"Automated Reverse Engineering of UML Sequence Diagrams for Dynamic Web Applications","Alalfi, M.H.; Cordy, J.R.; Dean, T.R.","Sch. of Comput., Queen''s Univ., Kingston, ON","Software Testing, Verification and Validation Workshops, 2009. ICSTW '09. International Conference on","1-4 April 2009","2009","","","287","294","This paper presents an approach and tool to automatically instrument dynamic Web applications using source transformation technology, and to reverse engineer a UML 2.1 sequence diagram from the execution traces generated by the resulting instrumentation. The result can be directly imported and visualized in a UML toolset such as rational software architect. Our approach dynamically filters traces to reduce redundant information that may complicate program understanding. While our current implementation works on PHP-based applications, the framework is easily extended to other scripting languages in plug-and-play fashion. In addition to supporting web application understanding, our tool is being used to recover traces from dynamic Web applications in support of Web application security analysis and testing. We demonstrate our method on the analysis of the popular Internet bulletin board system PhpBB 2.0.","","978-1-4244-4356-7","","10.1109/ICSTW.2009.8","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4976398","web applications modeling;web applications testing","Application software;Information filtering;Information filters;Information security;Instruments;Reverse engineering;Software tools;Testing;Unified modeling language;Visualization","Internet;Unified Modeling Language;program testing;reverse engineering;security of data;software architecture","Internet bulletin board system;PHP-based applications;PhpBB 2.0;UML 2.1 sequence diagram;Web application security analysis;Web application security testing;automated reverse engineering;plug-and-play fashion;rational software architect;source transformation technology","","","","3","","24","","","20090526","","IEEE","","IEEE Conference Publications","","","Dec. 14, 2013 1:29 PM EST","Dec. 14, 2013 1:29 PM EST"
"Combining MDE and UML to Reverse Engineer Web-Based Legacy Systems","Jianjun Pu; Yang, H.; Baowen Xu; Lei Xu; Chu, W.C.-C.","Software Technol. Res. Lab., De Montfort Univ., Leicester","Computer Software and Applications, 2008. COMPSAC '08. 32nd Annual IEEE International","July 28 2008-Aug. 1 2008","2008","","","718","725","The research in this paper focuses on an approach to reverse engineering Web-based legacy systems with the integration of model-driven engineering and UML. Three types of link-based models of Web-based legacy systems are presented. Web-based legacy systems are parsed to find judgement conditions of model, and UML diagrams are described based on the modelling rules.","0730-3157","978-0-7695-3262-2","978-0-7695-3262-2","10.1109/COMPSAC.2008.63","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4591655","Model-Driven Engineering;Reverse Engineering;Unified Modelling Language;Web-based Legacy System","Application software;Computer applications;Computer science;Displays;Internet;Laboratories;Model driven engineering;Reverse engineering;Unified modeling language;Web pages","Internet;Unified Modeling Language;software maintenance","UML diagrams;Web-based legacy systems;model-driven engineering;reverse engineering","","","","1","","5","","","20080808","","IEEE","","IEEE Conference Publications","","","Dec. 14, 2013 1:29 PM EST","Dec. 14, 2013 1:29 PM EST"
"A Fully Dynamic Approach to the Reverse Engineering of UML Sequence Diagrams","Ziadi, T.; da Silva, M.A.A.; Hillah, L.M.; Ziane, M.","LIP6-MoVe, Univ. Pierre et Marie Curie, Paris, France","Engineering of Complex Computer Systems (ICECCS), 2011 16th IEEE International Conference on","27-29 April 2011","2011","","","107","116","The reverse engineering of behavioral models consists in extracting high-level models that help understand the behavior of existing software systems. In the context of reverse engineering of sequence diagrams, most approaches strongly depend on the static analysis and instrumentation of the source code to produce correct diagrams that take into account control flow structures such as alternative blocks (""if""s) and repeated blocks (""loop""s). This approach is not possible with systems for which no source code is available anymore (e.g. some legacy systems). In this paper, we propose an approach for the reverse engineering of sequence diagrams from the analysis of execution traces produced dynamically by an object-oriented application. Our approach is fully based on dynamic analysis and reuses the k-tail merging algorithm to produce a Labeled Transition System (LTS) that merges the collected traces. This LTS is then translated into a sequence diagram which contains alternatives and loops. A prototype of this approach has been tested with a real world application that has been developed independently from the present work. Our results show that this approach can produce sequence diagrams in reasonable time and suggest that these diagrams are helpful in understanding the behavior of the underlying application.","","978-1-61284-853-2","978-0-7695-4381-9","10.1109/ICECCS.2011.18","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5773385","UML sequence diagrams;execution traces;reverse engineering","Asynchronous transfer mode;Java;Merging;Object oriented modeling;Prototypes;Reverse engineering;Unified modeling language","Unified Modeling Language;merging;object-oriented programming;program control structures;program diagnostics;reverse engineering","UML sequence diagram;alternative block;behavioral model;control flow structure;fully dynamic approach;k-tail merging algorithm;labeled transition system;object-oriented application;repeated block;reverse engineering;software system behavior;source code instrumentation;static analysis","","","","2","","22","","","20110527","","IEEE","","IEEE Conference Publications","","","Dec. 14, 2013 1:29 PM EST","Dec. 14, 2013 1:29 PM EST"
"A Metamodel to Carry Out Reverse Engineering of C++ Code into UML Sequence Diagrams","Lopez, S.M.; Alfonzo, G.A.; Perez OJ; Gonzalez, S.J.G.; Montes, R.A.","Comput. Sci. Dept., Nat. Center of Res. & Technol. Dev., Morelos","Electronics, Robotics and Automotive Mechanics Conference, 2006","26-29 Sept. 2006","2006","2","","331","336","When the documentation about the sequence of interactions among the objects in a program is not available but it is required, some work has to be done to document and to obtain the sequence diagrams either by making it in a manual way, or to apply a reverse engineering process that helps to recover the individual diagrams. The present work proposes a computerized method that interprets the characteristics of programs written in C++ code and applies a conversion algorithm that obtains the UML sequence diagrams. To test the method and their conversion algorithm a study case using the work carried out at Gordon College has been taken, which is an automatic teller machine simulator system written in C++","","0-7695-2569-5","","10.1109/CERMA.2006.100","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4019815","","Algorithm design and analysis;Data mining;Documentation;Information analysis;Object oriented modeling;Reverse engineering;Software maintenance;Software systems;Unified modeling language;Visualization","C++ language;Unified Modeling Language;object-oriented programming;reverse engineering;software maintenance;system documentation","C++ code;UML sequence diagram;automatic teller machine simulator system;conversion algorithm;meta model;program documentation;reverse engineering","","","","0","","15","","","20061204","","IEEE","","IEEE Conference Publications","","","Dec. 14, 2013 1:29 PM EST","Dec. 14, 2013 1:29 PM EST"
"Improving the Accuracy of UML Class Model Recovery","Kun Wang; Wuwei Shen","Michigan Univ., Kalamazoo","Computer Software and Applications Conference, 2007. COMPSAC 2007. 31st Annual International","24-27 July 2007","2007","1","","387","90","The gap between UML class models and their implementations impedes program understanding and analysis, and is a source of program errors. Although many reverse engineering techniques were proposed to bridge this gap, two major problems still exist. First, the accuracy of association inference from container classes is not adequate without considering iterators. Second, associations implemented by inherited fields are missed by existing techniques. In this paper, we present an approach to precisely and automatically recover a class model from Java byte code. Our approach tackles the above problems and improves the accuracy of the recovered models. The preliminary empirical results show that our approach achieved a higher accuracy for association inference than existing reverse engineering tools.","0730-3157","0-7695-2870-8","","10.1109/COMPSAC.2007.128","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4291029","","Bridges;Computer errors;Computer languages;Computer science;Containers;Impedance;Java;Reverse engineering;Software systems;Unified modeling language","Java;Unified Modeling Language;program diagnostics;reverse engineering;system recovery","Java byte code;UML class model recovery;association inference;container classes;iterators;program analysis;program understanding;reverse engineering","","","","0","","11","","","20070820","","IEEE","","IEEE Conference Publications","","","Dec. 14, 2013 1:29 PM EST","Dec. 14, 2013 1:29 PM EST"
"Empirical assessment of UML static object diagrams","Torchiano, Marco","Dipt. di Automatica e Informatica, Politecnico di Torino, Italy","Program Comprehension, 2004. Proceedings. 12th IEEE International Workshop on","24-26 June 2004","2004","","","226","230","The essential UML logic diagrams are the class diagrams: they represent the classes of objects that make up a program. Object diagrams are used as the basis to show scenarios of dynamic evolution of the software. The use of object diagrams to depict static structure is very rare. The purpose of this study is to investigate whether the use of static object diagrams can improve the comprehension of software systems. We conducted a study with 17 graduate students during a software engineering course. The students were asked to answer questions about a software system. The system was described either with a class diagram or with both a class diagram and an object diagram. The student asked multiple choice questions on four different systems. This study revealed that there is a statistically significant difference in the comprehension achievement for two of the systems. The effect of the presence of object diagrams can be classified of medium size. These results allow us to formulate new research questions that guide our future work in this area.","1092-8138","0-7695-2149-5","","10.1109/WPC.2004.1311064","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1311064","","Application software;Automatic logic units;Books;Collaboration;Object oriented modeling;Programming profession;Runtime;Software engineering;Software systems;Unified modeling language","Unified Modeling Language;diagrams;object-oriented programming;reverse engineering","UML logic diagrams;class diagrams;object diagrams;software comprehension;software engineering course;software evolution;software systems","","","","3","","8","","","20040712","","IEEE","","IEEE Conference Publications","","","Dec. 14, 2013 1:29 PM EST","Dec. 14, 2013 1:29 PM EST"
"Frontiers of reverse engineering: A conceptual model","Canfora, G.; Di Penta, M.","RCOST - Univ. of Sannio, Benevento","Frontiers of Software Maintenance, 2008. FoSM 2008.","Sept. 28 2008-Oct. 4 2008","2008","","","38","47","Software reverse engineering is a crucial task to reconstruct high-level views of a software system - with the purpose of understanding and/or maintaining it - when the only reliable source of information is the source code, or even the system binaries. This paper discusses key reverse engineering concepts through a UML conceptual model. Specifically, the model is composed of a set of UML class diagrams describing relationships existing among reverse engineering processes, tools, artifacts, and stakeholders.","","978-1-4244-2654-6","978-1-4244-2655-3","10.1109/FOSM.2008.4659247","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4659247","","Code standards;Documentation;Hardware;Information resources;Performance analysis;Reverse engineering;Software maintenance;Software protection;Software systems;Unified modeling language","Unified Modeling Language;reverse engineering;software engineering","UML class diagrams;software reverse engineering;software system;source code","","","","0","","59","","","20081024","","IEEE","","IEEE Conference Publications","","","Dec. 14, 2013 1:29 PM EST","Dec. 14, 2013 1:29 PM EST"
"Pattern-based design recovery from object-oriented languages to object process methodology","Dori, D.; Perelman, V.; Shlezinger, G.; Reinhartz-Berger, I.","Technion-Israel Inst. of Technol., Haifa, Israel","Software - Science, Technology and Engineering, 2005. Proceedings. IEEE International Conference on","22-23 Feb. 2005","2005","","","77","82","Keeping large software projects well documented is expensive and time consuming. Small code changes seldom propagate up to the design level. Therefore, design of large software becomes incoherent with the actual code. Yet understanding the original design intentions is crucial for supporting the life cycle of the software. Reverse engineering (RE) is the process of constructing a model of a system at a level that is more abstract than the source level at which the system is specified. In software, this amounts primarily to recovering the system design from its existing code. Most existing RE tools are UML-based. The majority of them recover only static aspects of the design, displayed by class diagrams. Others use pattern detection techniques to recover some of the high-level behavior. In this work, we argue that modeling dynamic behavior of even moderately complex systems is hardly feasible with UML due to its lack of hierarchy. As an alternative, we propose RE that is based on object process methodology (OPM), which provides a hierarchical view and a simple representation of design patterns.","","0-7695-2335-8","","10.1109/SWSTE.2005.16","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1421067","","Application software;Documentation;Iris;Object oriented modeling;Reverse engineering;Software design;Software maintenance;Software systems;Unified modeling language;Writing","Unified Modeling Language;object-oriented languages;object-oriented methods;object-oriented programming;reverse engineering","UML;object process methodology;object-oriented languages;pattern-based design recovery;reverse engineering;software projects","","","","0","","15","","","20050523","","IEEE","","IEEE Conference Publications","","","Dec. 14, 2013 1:29 PM EST","Dec. 14, 2013 1:29 PM EST"
"WARE: a tool for the reverse engineering of Web applications","Di Lucca, G.A.; Fasolino, A.R.; Pace, F.; Tramontana, P.; De Carlini, U.","Dipt. di Informatica e Sistemistica, Universita di Napoli Federico II, Italy","Software Maintenance and Reengineering, 2002. Proceedings. Sixth European Conference on","2002","2002","","","241","250","The development of Web sites and applications is increasing dramatically to satisfy the market requests. The software industry is facing the new demand under the pressure of a very short time-to-market and an extremely high competition. As a result, Web sites and applications are usually developed without a disciplined process: Web applications are directly coded and no, or poor, documentation is produced to support the subsequent maintenance and evolution activities, thus compromising the quality of the applications. This paper presents a tool for reverse engineering Web applications. UML diagrams are used to model a set of views that depict several aspects of a Web application at different abstraction levels. The recovered diagrams ease the comprehension of the application and support its maintenance and evolution. A case study, carried out with the aim of assessing the effectiveness of the proposed tool, allowed relevant information about some real Web applications to be successfully recovered and modeled by UML diagrams","1534-5351","0-7695-1438-3","","10.1109/CSMR.2002.995811","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=995811","","Application software;Computer industry;Documentation;Internet;Pressing;Reverse engineering;Software systems;Time to market;Unified modeling language;World Wide Web","Internet;information resources;program testing;reverse engineering;software engineering;specification languages","UML diagrams;WARE;Web applications;Web sites;abstraction levels;reverse engineering;software development","","","","24","","24","","","20020807","11 Mar 2002-13 Mar 2002","IEEE","","IEEE Conference Publications","","","Dec. 14, 2013 1:29 PM EST","Dec. 14, 2013 1:29 PM EST"
"Reverse engineering as a means of improving and adapting legacy finite element code","Hoole, S.R.H.; Arudchelvam, T.","Dept. of Eng. & Sci., Rensselaer Polytech. Inst., Hartford, CT, USA","Industrial and Information Systems (ICIIS), 2009 International Conference on","28-31 Dec. 2009","2009","","","227","232","The development of code for finite elements-based field computation has been going on at a pace since the 1970s, yielding code that was not put through the software lifecycle - where code is developed through a sequential process of requirements elicitation from the user/client to design, analysis, implementation and testing (with loops going back from the second stage onwards as dissatisfactions are identified or questions arise) and release and maintenance. As a result, today we have legacy code running into millions of lines, implemented without planning and not using proper state-of-the-art software design tools. It is necessary to redo this code to exploit object oriented facilities and make corrections or run on the web with Java. Object oriented code's principal advantage is reusability. It is ideal for describing autonomous agents so that values inside a method are private unless otherwise so provided - that is encapsulation makes programming neat and less error-prone in unexpected situations. Recent advances in software make such reverse engineering/reengineering of this code into object oriented form possible. The purpose of this paper is to show how existing finite element code can be reverse/re-engineered to improve it. Taking sections of working finite element code, especially matrix computation for equation solution as examples, we put it through reverse engineering to arrive at the effective UML design by which development was done and then translate it to Java. This then is the starting point for analyzing the design and improving it without having to throw away any of the old code.","","978-1-4244-4836-4","978-1-4244-4837-1","10.1109/ICIINFS.2009.5429859","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5429859","Class and Sequence Diagrams;FORTRAN;Finite Elements;Java;Legacy Software;Reengineering;Reverse Engineering;UML","Autonomous agents;Encapsulation;Finite element methods;Java;Life testing;Reverse engineering;Sequential analysis;Software design;Software maintenance;Software testing","Java;Unified Modeling Language;finite element analysis;object-oriented programming;reverse engineering;software maintenance","Java;UML design;autonomous agents;finite elements-based field computation;legacy code;object-oriented code;reverse engineering;software lifecycle","","","","0","","18","","","20100311","","IEEE","","IEEE Conference Publications","","","Dec. 14, 2013 1:29 PM EST","Dec. 14, 2013 1:29 PM EST"
"An approach for reverse engineering of web-based applications","Di Lucca, G.A.; Di Penta, M.; Antoniol, G.; Casazza, G.","Dipt. di Inf. e Sistemistica, Naples Univ., Italy","Reverse Engineering, 2001. Proceedings. Eighth Working Conference on","2001","2001","","","231","240","The new possibilities offered by WEB applications are pervasively and radically changing several areas. WEB applications, compared to WEB sites, offer substantially greater opportunities: a WEB application provides the WEB user with a means to modify the site status. WEB applications must cope with an extremely short development/evolution life cycle. Usually, they are implemented without producing any useful documentation for subsequent maintenance and evolution, thus compromising the desired high level of flexibility, maintainability, and adaptability that is de-facto necessary to compete and survive to market shakeout. This paper presents an approach inspired by the reverse engineering arena and a tool prototype supporting WEB application reverse engineering activities, to help maintain, comprehend and evolve WEB applications. The approach defines a set of abstract views, modeled using UML diagrams, organized into a hierarchy of different abstraction levels, depicting several aspects of a WEB application to facilitate its comprehension. A real world WEB application was used as case study, and information previously not available was recovered, with encouraging results","1095-1350","0-7695-1303-4","","10.1109/WCRE.2001.957827","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=957827","","Application software;Companies;Documentation;Globalization;Prototypes;Reverse engineering;Software maintenance;Unified modeling language;Web sites;World Wide Web","Internet;information resources;reverse engineering;specification languages","UML diagrams;WEB sites;adaptability;life cycle;maintainability;reverse engineering;tool prototype;web-based applications","","","","11","","","","","20020807","02 Oct 2001-05 Oct 2001","IEEE","","IEEE Conference Publications","","","Dec. 14, 2013 1:29 PM EST","Dec. 14, 2013 1:29 PM EST"
"A language and platform-independent approach for reverse engineering","Duffy, E.B.; Malloy, B.A.","Dept. of Comput. Sci., Clemson Univ., SC, USA","Software Engineering Research, Management and Applications, 2005. Third ACIS International Conference on","11-13 Aug. 2005","2005","","","415","422","We present an approach for reverse engineering a program to capture design and implementation artifacts such as metrics and UML class or sequence diagrams. We also describe an implementation of our approach, libthorin. However, unlike previous reverse engineering tools, libthorin can be applied to a variety of programming languages including C, C++, Java, Fortran 90 and C#. Moreover, libthorin can provide both coarse-grained and fine-grained information about the program under development to enable re-engineering of information and high-level diagrams such as metrics and class diagrams, or low-level diagrams such as sequence diagrams, control flow graphs and other program representations and analysis tools for testing, debugging and profiling an application under development.","","0-7695-2297-1","","10.1109/SERA.2005.9","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1563191","","Application software;Computer languages;Debugging;Flow graphs;Information analysis;Java;Reverse engineering;Software testing;Unified modeling language;Visualization","Unified Modeling Language;XML;flowcharting;reverse engineering;software metrics;software tools;systems re-engineering;tree data structures","UML class diagram;XML;control flow graph;information reengineering;libthorin tool;platform-independent approach;program analysis tool;program debugging;program profiling;program representation;program testing;programming languages;reverse engineering;sequence diagram;software metrics","","","","0","","18","","","20051227","","IEEE","","IEEE Conference Publications","","","Dec. 14, 2013 1:29 PM EST","Dec. 14, 2013 1:29 PM EST"
"Reverse engineering Web applications","Tramontana, P.","Dipt. di Informatica e Sistemistica, Universita di Napoli Federico II, Italy","Software Maintenance, 2005. ICSM'05. Proceedings of the 21st IEEE International Conference on","26-29 Sept. 2005","2005","","","705","708","The heterogeneous and dynamic nature of components making up a Web application, the lack of effective programming mechanisms for implementing basic software engineering principles in it, and undisciplined development processes induced by the high pressure of a very short time-to-market, make Web application maintenance a challenging problem. A relevant issue consists of reusing the methodological and technological experience in the sector of traditional software maintenance, and exploring the opportunity of using reverse engineering to support effective Web application maintenance. This article presents an approach for reverse engineering Web applications. The approach include the definition of reverse engineering methods and supporting software tools, that help to understand existing undocumented Web applications to be maintained or evolved, through the reconstruction of UML diagrams. Some validation experiments have been carried out and they showed the usefulness of the proposed approach and highlighted possible areas for improvement of its effectiveness.","1063-6773","0-7695-2368-4","","10.1109/ICSM.2005.77","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1510178","","Application software;Documentation;Dynamic programming;Multimedia databases;Reverse engineering;Software maintenance;Software systems;Time to market;Unified modeling language;Web and internet services","Internet;Unified Modeling Language;reverse engineering;software maintenance;software tools","UML diagrams;Web application reverse engineering;software engineering principles;software maintenance;software tools","","","","0","","14","","","20051121","","IEEE","","IEEE Conference Publications","","","Dec. 14, 2013 1:29 PM EST","Dec. 14, 2013 1:29 PM EST"
"Improving program comprehension by enhancing program constructs: An analysis of the Umple language","Forward, A.; Lethbridge, T.C.; Brestovansky, D.","Sch. of Inf. Technol. & Eng. (SITE), Univ. of Ottawa, Ottawa, ON","Program Comprehension, 2009. ICPC '09. IEEE 17th International Conference on","17-19 May 2009","2009","","","311","312","Umple is a set of extensions to object-oriented languages that provides a concrete syntax for UML abstractions like associations. We argue that Umple will help increase program comprehension by allowing developers to describe a system at a more abstract level, and by reducing the volume of code.","1092-8138","978-1-4244-3998-0","978-1-4244-3997-3","10.1109/ICPC.2009.5090073","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5090073","","Application software;Computer languages;Concrete;Information analysis;Information technology;Investments;Object oriented modeling;Object oriented programming;Risk analysis;Unified modeling language","Unified Modeling Language;object-oriented languages;programming languages","UML abstractions;language analysis;object-oriented languages;program comprehension;program constructs","","","","3","","8","","","20090619","","IEEE","","IEEE Conference Publications","","","Dec. 14, 2013 1:29 PM EST","Dec. 14, 2013 1:29 PM EST"
"Reverse Engineering Finite State Machines from Rich Internet Applications","Amalfitano, D.; Fasolino, A.R.; Tramontana, P.","Consorzio Interuniversitario Naz. per l''Inf., Naples","Reverse Engineering, 2008. WCRE '08. 15th Working Conference on","15-18 Oct. 2008","2008","","","69","73","In the last years, rich Internet applications (RIAs) have emerged as a new generation of Web applications offering greater usability and interactivity than traditional ones. At the same time, RIAs introduce new issues and challenges in all the Web application lifecycle activities. As an example, a key problem with RIAs consists of defining suitable software models for representing them and validating reverse engineering techniques for obtaining these models effectively.This paper presents a reverse engineering approach for abstracting finite state machines representing the client-side behaviour offered by RIAs. The approach is based on dynamic analysis of the RIA and employs clustering techniques for solving the problem of state explosion of the state machine. A case study illustrated in the paper shows the results of a preliminary experiment where the proposed process has been executed with success for reverse engineering the behaviour of an existing RIA.","1095-1350","978-0-7695-3429-9","","10.1109/WCRE.2008.17","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4656395","Ajax;FSM;RIA;Reverse Engineering","Application software;Automata;Explosions;Information retrieval;Internet;Java;Reverse engineering;Search engines;US Department of Transportation;Usability","Internet;finite state machines;pattern clustering;reverse engineering","Web application lifecycle;clustering techniques;finite state machines;reverse engineering;rich Internet applications;state explosion","","","","6","","15","","","20081024","","IEEE","","IEEE Conference Publications","","","Dec. 14, 2013 1:29 PM EST","Dec. 14, 2013 1:29 PM EST"
"Towards the reverse engineering of UML sequence diagrams","Briand, L.C.; Labiche, Y.; Miao, Y.","Carleton University","Reverse Engineering, 2003. WCRE 2003. Proceedings. 10th Working Conference on","13-16 Nov. 2003","2003","","","57","66","<div style=""font-variant: small-caps; font-size: .9em;"">First Page of the Article</div><img class=""img-abs-container"" style=""width: 95%; border: 1px solid #808080;"" src=""/xploreAssets/images/absImages/01287237.png"" border=""0"">","1095-1350","0-7695-2027-8","","10.1109/WCRE.2003.1287237","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1287237","","Context modeling;Data visualization;Information analysis;Information retrieval;Object oriented modeling;Reverse engineering;Software quality;System testing;Systems engineering and theory;Unified modeling language","","","","","","20","","","","","20040419","","IEEE","","IEEE Conference Publications","","","Dec. 14, 2013 1:29 PM EST","Dec. 14, 2013 1:29 PM EST"
"Tracing of state machine execution in the model-driven development framework","Derezinska, A.; Szczykulski, M.","Inst. of Comput. Sci., Warsaw Univ. of Technol., Warsaw, Poland","Information Technology (ICIT), 2010 2nd International Conference on","28-30 June 2010","2010","","","109","112","Framework for eXecutable UML (FXU) supports a model-driven approach for creation of reliable applications in C#. Basing on UML classes and their state machines, a source code is generated and executed using a run-time library. All modeling concepts of UML behavioral state machines can be used in the FXU. Tracing of program execution in terms of elements of origin state machines assists program comprehension and verification. This paper presents a new component of the framework for observing traces of program execution. The state machine tracing improved model-driven engineering of an application in comparison to the direct analysis of textual logs generated during the program execution. We discuss system requirements, steps of tracing process and advantages and disadvantages of the solution. The approach was applied in the development of an application simulating a presence server for the status service of a social network model.","","978-1-4244-8182-8","","","http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5553380","Model-Driven Development;UML;state machine","Software;Unified modeling language","Unified Modeling Language;finite state machines;program diagnostics;program verification;source coding","C#;UML behavioral state machines;eXecutable UML framework;model-driven development framework;program comprehension;program verification;run-time library;source code;state machine execution tracing","","","","0","","12","","","20100823","","IEEE","","IEEE Conference Publications","","","Dec. 14, 2013 1:21 PM EST","Dec. 14, 2013 1:21 PM EST"
